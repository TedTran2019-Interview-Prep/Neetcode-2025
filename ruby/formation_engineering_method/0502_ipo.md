```ruby
=begin
IPO
k distinct projects
Maximize total capital after finishing AT MOST k projects
n projects, ith is profits[i], capitals[i] to start
w capital: obtain its pure profit and added to total capital
at most k projects to maximize final capital, return final maximized capital
So if profit <= capital, don't bother it's just wasteful (no or negative returns)

You can only do K projects
You want to do the K projects that have the most profit - starting capital that you can start with your
original capital

Min heap of [profit, starting capital, profit]
- don't push if profit is <= 0
If your capital goes over starting capital, put that from min heap into max heap of net profit
At start and after every project, pull the top of profit
Repeat K times or until there's nothing inside of the profit max heap

My mistake:
Starting capital isn't lost and you just want to return maximum including start at end (aka what w is)

Naive two heap solution times out on 39/40
Mapping info + heapify is O(N) each
Pushing many elements from min_heap to max_heap can be KlogN
Oh, but popping that amount of elements is also KlogN...
2KlogN + 2N

Supposedly this is the optimal approach, but Ruby is just too slow sadly.
Maybe I can sort (nlogn) info, then just shift out values instead? Works!
=end
```
